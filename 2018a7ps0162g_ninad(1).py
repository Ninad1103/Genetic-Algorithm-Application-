# -*- coding: utf-8 -*-
"""2018A7PS0162G_Ninad.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_N_ungb7JJM4-PpoBaWknqmik7N4Gpko
"""

from random import sample 
from random import randint 
from random import choices

print("Enter 1 for Queens problem and 2 for Travelling salesman problem")
x = input()
if (x == '1'):
  def check(sample_state):
    coordinate_list = []
    for i in range(8):
      coordinate_list.append((i+1,sample_state[i]))
    #print(coordinate_list)    
    attack_pairs = 0
    for i in range(8):
      for j in range(i+1,8):
        if abs((coordinate_list[i][1] - coordinate_list[j][1])/(coordinate_list[i][0] - coordinate_list[j][0])) == 1 or abs((coordinate_list[i][1] - coordinate_list[j][1])/(coordinate_list[i][0] - coordinate_list[j][0])) == 0:
          attack_pairs = attack_pairs+1
    return 29 - attack_pairs


  population = []
  for o in range(100):
    population.append([1,1,1,1,1,1,1,1])

  #print(len(new_population))
  #optimization 

  def selection(population):  
    #print(len(population))
    weights = []
    for i in range(100):
      weights.append(check(population[i]))
    first_choice = choices(population,weights=weights,k=1)
    weights2 = weights
    weights2.remove(check(first_choice[0]))
    temp = []
    temp = population
    temp.remove(first_choice[0])
    
    second_choice = choices(temp,weights = weights2, k=1)
    temp.insert(1,first_choice[0])
    #print(len(population))
    return first_choice[0], second_choice[0]     


  def genetic_algorithm(population):
    max_iterations = 20000
    flag = 0
    iterations = 0
    sequence = [1,2,3,4,5,6]
    costs_attack = []
    while (iterations != max_iterations and flag!=1):
      new_population = []
      for i in range(100):
        x1 = []
        x2 = []
        #selecting 2 parents based on fitness function
        #x1, x2 = selection_opti(population)
        
        #normal selection
        
        x1,x2 = selection(population)

        #reproducing

        child = [0,0,0,0,0,0,0,0] 
        child1 = [0,0,0,0,0,0,0,0] 
        child2 = [0,0,0,0,0,0,0,0] 
        c = sample(sequence,1)
        #optimization could be make the 2 children and pick the fittest
        for j in range(c[0]):
          child1[j] = x1[j]
          child2[j] = x2[j]
        for j in range(c[0],8):
          child1[j] = x2[j]
          child2[j] = x1[j]
        #choosing the child 
        child = []
        if (check(child1)>check(child2)):
          child = child1
        else:
          child = child2   
      
        #mutation
        if (randint(1,100)) < 50:
          k = randint(0,7)
          l = randint(1,8)
          child[k] = l
        #child <- mutated child based on a probability
        new_population.append(child)
      population = new_population
      for i in range(100):
        if(check(population[i]) == 29):
          flag=1

      iterations = iterations + 1
      ml = population[0]
      for g in range(100):
        if (check(population[g])>check(ml)):
          ml = population[g]
      costs_attack.append(check(ml))    
      print("Iteration:",iterations,check(ml))
      #print(iterations)
    #plt.plot(costs_attack)
    #plt.show()
    max1 = population[0]
    for i in range(100):
      if(check(population[i])>check(max1)):
        max1 = population[i]
    
    print(max1)
    return max1, iterations

  genetic_algorithm(population)
else:
  a = []
  for i in range(14): 
    a.append([])
    for j in range(14):
      a[i].append(1000)
    #print(a[i])

  a[0][0] = 0
  a[1][1] = 0
  a[2][2] = 0
  a[3][3] = 0
  a[4][4] = 0
  a[5][5] = 0
  a[6][6] = 0
  a[7][7] = 0
  a[8][8] = 0
  a[9][9] = 0
  a[10][10] = 0
  a[11][11] = 0
  a[12][12] = 0
  a[13][13] = 0
  a[0][6] = 0.15
  a[0][9] = 0.2
  a[0][11] = 0.12
  a[1][7] = 0.19
  a[1][8] = 0.4
  a[1][13] = 0.13
  a[2][3] = 0.6
  a[2][4] = 0.22
  a[2][5] = 0.4
  a[2][8] = 0.2
  a[3][2] = 0.6
  a[3][5] = 0.21
  a[3][10] = 0.3
  a[4][2] = 0.22
  a[4][8] = 0.18
  a[5][2] = 0.4
  a[5][3] = 0.21
  a[5][10] = 0.37
  a[5][11] = 0.6
  a[5][12] = 0.26
  a[5][13] = 0.9
  a[6][0] = 0.15 
  a[6][10] = 0.55 
  a[6][11] = 0.18
  a[7][1] = 0.19
  a[7][9] = 0.56 
  a[7][13] = 0.17
  a[8][1] = 0.4
  a[8][2] = 0.2
  a[8][4] = 0.18
  a[8][13] = 0.6
  a[9][0] = 0.2
  a[9][7] = 0.56
  a[9][11] = 0.16
  a[9][13] = 0.5
  a[10][3] = 0.3
  a[10][5] = 0.37
  a[10][6] = 0.55
  a[10][12] = 0.24
  a[11][0] = 0.12
  a[11][5] = 0.6
  a[11][6] = 0.18
  a[11][9] = 0.16
  a[11][12] = 0.4
  a[12][5] = 0.26
  a[12][10] = 0.24
  a[12][11] = 0.4
  a[13][1] = 0.13
  a[13][5] = 0.9
  a[13][7] = 0.17
  a[13][8] = 0.6
  a[13][9] =  0.5

  sequence2 = [0,1,2,3,4,5,6,7,8,9,10,11,12,13]  
  def reproduce(s1, s2):
    random_list = sample(sequence2,2)
    k = random_list[0]
    j = random_list[1]
    #print(k, j)
    child = [0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    list1 = []
    val = []
    #x1 = [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
    #x2 = [14,13,12,11,10,9,8,7,6,5,4,3,2,1]
    if (j<k):
      for l in range(j,k+1):
        child[l] = s1[l]  
        list1.append(child[l])
      #print(child)  
      for l in range(14):
        flag=1
        for p in range(len(list1)):
          if (s2[l] == list1[p]):
            flag=0    
        if (flag == 1):
          val.append(s2[l])
      #print(val)
      index = 0    
      for l in range(j):
        child[l] = val[index]  
        index = index + 1
      l = k+1 
      while (l<14):
        child[l] = val[index]
        index = index + 1     
        l = l + 1
    else :   
      for l in range(k,j+1):
        child[l] = s1[l]  
        list1.append(child[l])
      
      #print(child)  
      for l in range(14):
        flag=1
        for p in range(len(list1)):
          if (s2[l] == list1[p]):
            flag=0    
        if (flag == 1):
          val.append(s2[l])
      #print(val)
      index = 0    
      for l in range(k):
        child[l] = val[index]  
        index = index + 1
      l = j+1 
      while (l<14):
        child[l] = val[index]
        index = index + 1     
        l = l + 1   
    #print(child)
    return child


  def selection_opti2(population2):
    for i in range(50):
      for j in range(i+1,50):
        if (fitness(population2[i])<fitness(population2[j])):
          temp = []
          temp = population2[i]
          population2[i] = population2[j]
          population2[j] = temp      
    return population2[0], population2[1]

  def cost(state):
    total = 0
    for i in range(13):
      if (a[state[i]-1][state[i+1]-1] != 1000):
        total = total + (a[state[i]-1][state[i+1]-1])
      else:
        total = total + (a[state[i]-1][state[i+1]-1])
    total = total + a[state[13]-1][state[0]-1]
    return total

  def fitness(state):
    return  10000/cost(state)


  population2 = []
  for o in range(50):
    population2.append([1,2,3,4,5,6,7,8,9,10,11,12,13,14])

  def genetic_algo(population2):
    max_iterations = 5000
    iterations = 0
    costs = []
    mt = population2[0]
    while (iterations<=max_iterations and cost(mt)>4):
      new_population = []
      for i in range(50):
        x1 = []
        x2 = []
        #parent selection
        x1, x2 = selection_opti2(population2)

        #reproduce
        child = reproduce(x1, x2)

        #mutate
        if (randint(1,100)) < 70:
          mutation_list = sample(sequence2,2)
          m = mutation_list[0]
          n = mutation_list[1]
          child[m], child[n] = child[n], child[m]
        new_population.append(child)
      population2 = new_population
      iterations = iterations +1 
      mt = population2[0]
      for o in range(50):
        if (fitness(population2[o])>fitness(mt)):
          mt = population2[o]
      costs.append(cost(mt))    
      print("Iteration:",iterations,cost(mt))
      #print(iterations)
    #plt.plot(costs)  
    #plt.show()
    max1 = population2[0]
    for i in range(50):
      if(fitness(population2[i])>fitness(max1)):
        max1 = population2[i]    
    print(max1)  
    return max1, cost(max1)

  genetic_algo(population2)